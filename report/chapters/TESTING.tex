\chapter{Testing}
\label{ch:testing}

Per ogni servizio del sistema è stato adottato, ove possibile, il paradigma di programmazione TDD (Test Driven Development). Questo approccio prevede che i test vengano scritti prima del codice, in modo da guidarne lo sviluppo e garantire che il software prodotto soddisfi i requisiti specificati.

La strategia di testing adottata si ispira alla \textbf{test pyramid} descritta in \cite{richardson2019}, che prevede una distribuzione dei test su livelli crescenti di granularità: molti \textit{unit test} alla base, un numero inferiore di \textit{integration test}, e pochi test ai livelli superiori.

\section{Strumenti di Testing}

Le operazioni di testing sono state implementate con \textbf{Jest} per quanto riguarda i servizi basati su Node.js, generando report chiari e di facile lettura. Il componente middleware, scritto in Java, produceva invece risultati di test meno comprensibili. Per risolvere questo problema è stata introdotta, nel file di build Gradle, la libreria \href{https://plugins.gradle.org/plugin/com.adarshr.test-logger}{\underline{Test Logger}}, tramite la seguente configurazione:

\begin{lstlisting}[language=Java, caption={Configurazione del Test Logger}, label=list:gradle_testlogger]
import com.adarshr.gradle.testlogger.TestLoggerExtension
import com.adarshr.gradle.testlogger.TestLoggerPlugin
import com.adarshr.gradle.testlogger.theme.ThemeType

testlogger {
    theme = ThemeType.MOCHA
    showExceptions = true
    showStackTraces = true
    showFullStackTraces = false
    showCauses = true
    slowThreshold = 2000
    showSummary = true
    showSimpleNames = false
    showPassed = true
    showSkipped = true
    showFailed = true
    showOnlySlow = false
    showStandardStreams = false
    showPassedStandardStreams = true
    showSkippedStandardStreams = true
    showFailedStandardStreams = true
    logLevel = LogLevel.LIFECYCLE
}
\end{lstlisting}

\section{Architettura dei Componenti e Strategia di Testing}

L'architettura interna di ciascun servizio segue una struttura a due livelli:
\begin{itemize}
    \item \textbf{Classi controller}: espongono le rotte e delegano alle classi di servizio.
    \item \textbf{Classi di servizio}: contengono la logica di business.
\end{itemize}

Questa separazione consente di applicare strategie di testing differenziate per ciascun livello, coerentemente con quanto suggerito dall'architettura esagonale \cite{richardson2019}: le classi di servizio vengono testate con \textit{solitary unit test} che ne verificano la logica in isolamento, mentre le interazioni tra servizi e con l'infrastruttura vengono verificate ai livelli superiori della piramide.

\section{Unit Test}

Gli \textit{unit test} costituiscono la base della test pyramid e sono orientati alla tecnologia. Nel nostro sistema, sono stati implementati come \textbf{solitary unit test} sulle classi di servizio, verificando la correttezza della logica di business in isolamento dalle dipendenze esterne.

Non sono stati realizzati unit test dedicati per le classi controller dei singoli servizi. Secondo la strategia suggerita in \cite{richardson2019}, i controller andrebbero testati con solitary unit test che mockano i servizi sottostanti; nel nostro caso, si è scelto di verificarne il comportamento ai livelli superiori della piramide, tramite i test descritti nella Sezione~\ref{sec:component_test}. Si tratta di una limitazione consapevole, motivata dalla semplicità dei controller che si limitano a delegare alle classi di servizio.

\section{Integration Test}
\label{sec:integration_test}

Gli \textit{integration test} si collocano al livello immediatamente superiore agli unit test nella piramide. Il loro scopo è verificare che un servizio possa interagire correttamente con i servizi infrastrutturali da cui dipende, in particolare i database \cite{richardson2019}.

Nel nostro sistema, ad eccezione del servizio contenente la business logic --- che non ha dipendenze verso database né verso altri servizi --- sono stati realizzati \textbf{persistence integration test} per verificare il corretto collegamento tra i servizi e i rispettivi database (MySQL e MongoDB).

L'esempio seguente mostra un persistence integration test che verifica l'interazione tra il servizio di gioco e MongoDB:

\begin{lstlisting}[language=Java, caption={Persistence integration test per MongoDB}, label=list:mongo_test]
@TestInstance(Lifecycle.PER_CLASS)
@ExtendWith(VertxExtension.class)
public class StatisticMongoTest {
    private static final int TRICKS = 10;
    private final User userTest = new User("user", UUID.randomUUID(), false);
    private static final int MARAFFA_PLAYERS = 4;
    private static final int EXPECTED_SCORE = 11;
    private static final String PASSWORD = "1234";
    private static final GameMode GAME_MODE = GameMode.CLASSIC;
    private Vertx vertx;
    private GameService gameService;
    private static final CardSuit UNDEFINED_TRUMP = CardSuit.NONE;
    private final Card<CardSuit, CardValue> cardTest = new Card<>(CardValue.THREE, CardSuit.CLUBS);
    private final Boolean isSuitFinished = true;
    private final MongoStatisticManager mongoStatisticManager = new MongoStatisticManager(
        Dotenv.configure().filename("env.example").load().get("MONGO_USER", "user"),
        Dotenv.configure().filename("env.example").load().get("MONGO_PASSWORD", "password"),
        Dotenv.configure().filename("env.example").load().get("MONGO_HOST", "localhost"),
        Integer.parseInt(Dotenv.configure().filename("env.example").load().get("MONGO_PORT", "27127")),
        Dotenv.configure().filename("env.example").load().get("MONGO_DATABASE", "maraffa-test")
    );

    @BeforeAll
    public void setUp() {
        this.vertx = Vertx.vertx();
        this.gameService = new GameService(this.vertx, this.mongoStatisticManager);
    }

    @AfterAll
    public void tearDown() {
        this.vertx.close();
    }

    @Test
    public void prepareGame() {
        final String gameID = this.gameService
            .createGame(MARAFFA_PLAYERS, this.userTest, EXPECTED_SCORE, GAME_MODE.toString())
            .getString(Constants.GAME_ID);
        final var doc = this.mongoStatisticManager.getRecord(gameID + "-0");
        assertNotNull(doc);
    }
}
\end{lstlisting}

Il test segue le fasi canoniche: \textbf{setup} (inizializzazione di Vert.x e del servizio con connessione a MongoDB), \textbf{execute} (creazione di una partita e recupero del record), \textbf{verify} (asserzione sulla presenza del documento), \textbf{teardown} (chiusura di Vert.x).

\section{Component Test}
\label{sec:component_test}

I \textit{component test} verificano il comportamento di un servizio trattandolo come una \textit{black box} e interagendo con esso attraverso la sua API \cite{richardson2019}.

Nel nostro sistema, il componente middleware svolge il ruolo di API Gateway e si occupa di mettere in comunicazione i servizi tra loro e con il frontend. I test realizzati al suo interno verificano che le API esposte dagli altri servizi rispondano correttamente e che i contenuti vengano deserializzati nel formato atteso.

Questi test, pur non utilizzando un framework di contract testing come Spring Cloud Contract o Pact, svolgono nella pratica un ruolo analogo ai \textbf{consumer-driven contract test}: il middleware agisce come \textit{consumer} delle API degli altri servizi, e i test verificano che il \textit{provider} rispetti il contratto implicito (endpoint corretto, struttura della response attesa, status code).

\section{Testing Asincrono}
\label{sec:async_test}

Durante la scrittura dei test del servizio Java, alcune operazioni risultavano asincrone; è stato quindi necessario attendere il completamento di tali operazioni prima di poter validare i test.
La struttura di test standard fornita da Vert.x non era sufficiente in un primo momento. La forma classica dei test è la seguente:

\begin{lstlisting}[language=Java, caption={Esempio di test sincrono con Vert.x}, label=list:test_std_vertx]
@Test
public void createGameTest(final VertxTestContext context) {
    final JsonObject gameResponse = this.gameService.createGame(
        MARAFFA_PLAYERS, TEST_USER, EXPECTED_SCORE, GAME_MODE.toString(), PASSWORD);
    Assertions.assertEquals(UUID_SIZE, gameResponse.getString(Constants.GAME_ID).length());
    context.completeNow();
}
\end{lstlisting}

Per gestire correttamente le operazioni asincrone, sono stati adottati i seguenti accorgimenti:
\begin{itemize}
    \item utilizzo del decoratore \textit{@Timeout} fornito da JUnit Jupiter, che consente di impostare un limite di tempo oltre il quale il test fallisce automaticamente, utile per gestire servizi esterni che non rispondono;
    \item uso asincrono del \textit{VertxTestContext}, che consente di completare il test solo quando tutte le operazioni asincrone sono terminate;
    \item introduzione, nei servizi, di una struttura di risposta che include una chiave \texttt{"error"} in caso di fallimento, poiché il test non può accedere direttamente alla risposta HTTP e quindi allo status code.
\end{itemize}

Il seguente esempio mostra un test asincrono correttamente strutturato:

\begin{lstlisting}[language=Java, caption={Esempio di test asincrono con Vert.x}, label=list:test_async_vertx]
@Timeout(value = 10, unit = TimeUnit.SECONDS)
@Test
public void testGetShuffledDeckOK(final VertxTestContext context) {
    final JsonObject gameResponse = this.gameService.createGame(
        4, TEST_USER, 41, GameMode.CLASSIC.toString(), PASSWORD);
    this.businessLogicController
        .getShuffledDeck(UUID.fromString(gameResponse.getString(Constants.GAME_ID)), 4)
        .whenComplete((res, err) -> {
            context.verify(() -> {
                assertNull(res.getString("error"));
                context.completeNow();
            });
        });
}
\end{lstlisting}

\section{Livelli Superiori della Piramide}

I livelli superiori della test pyramid --- in particolare gli \textit{end-to-end test}, che secondo \cite{richardson2019} dovrebbero essere minimizzati data la loro complessità, lentezza e fragilità --- non sono stati implementati in forma automatizzata. La verifica del comportamento complessivo dell'applicazione è stata condotta tramite sessioni di \textit{alpha testing} con più utenti attraverso il frontend, coprendo in modo esplorativo i percorsi principali dell'utente (\textit{user journey}).