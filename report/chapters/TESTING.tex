\chapter{Testing}
\label{ch:testing}

Per ogni servizio in questo sistema è stato adottato, ove possibile, il paradigma di programmazione TDD, cioè Test Driven Development. Questo approccio prevede che i test siano scritti prima del codice, in modo da guidare lo sviluppo e garantire che il codice prodotto soddisfi i requisiti specificati.
Le operazioni di testing sono stata implementate con Jest per quanto riguarda i servizi che usano Node.js, generando di fatto un report abbastanza comprensibile. Il componente middleware, scritto in Java, invece, generava risultati di test non così chiari. Per modificare questo comportamento, è stata introdotta una dipendenza nel build Gradle che permette di avere un report più dettagliato e comprensibile. 
La libreria \href{https://plugins.gradle.org/plugin/com.adarshr.test-logger}{\underline{Test Logger}}, tramite una piccola configurazione nel file build.gradle come qui riportata, ha soddisfatto le nostre esigenze.

\begin{lstlisting}[language=Java, caption={Test logger}, label=list:gradle_testlogger]
import com.adarshr.gradle.testlogger.TestLoggerExtension
import com.adarshr.gradle.testlogger.TestLoggerPlugin
import com.adarshr.gradle.testlogger.theme.ThemeType

testlogger {
    theme = ThemeType.MOCHA
    showExceptions = true
    showStackTraces = true
    showFullStackTraces = false
    showCauses = true
    slowThreshold = 2000
    showSummary = true
    showSimpleNames = false
    showPassed = true
    showSkipped = true
    showFailed = true
    showOnlySlow = false
    showStandardStreams = false
    showPassedStandardStreams = true
    showSkippedStandardStreams = true
    showFailedStandardStreams = true
    logLevel = LogLevel.LIFECYCLE
}
\end{lstlisting}
\vspace{1cm}

L'architettura dei componenti si può riassumere in questo modo:
\begin{itemize}
	\item \textbf{Classi controller}: che hanno la funzione di esporre le rotte e di contenere al loro interno classi di servizio.
	\item \textbf{Classi di servizio}: che contengono la logica di business.
\end{itemize}

Gli unit test vengono eseguiti sulle classi di servizio, andando a testare la logica di business. Questo approccio permette di avere una copertura maggiore del codice e di garantire che la logica di business sia corretta.

\subsection{Integration Test}

Avendo implementato un'architettura a microservizi, è necessario testare anche il corretto funzionamento delle comunicazioni tra i servizi. Per fare ciò, sono stati implementati dei test di integrazione che verificassero il corretto funzionamento delle API esposte dai servizi. 
Questi test sono stati implementati nel componente middleware che ha il compito di mettere in comunicazione i servizi tra di loro e il frontend. 
Testando di fatto i controller degli altri servizi e che i contenuti venissero correttamente deserializzati. Nono sono quindi stati creati unit test sui controller all'interndo dei singoli servizi che testassero i Controller.

Al di fuori del servizio della Business logic che non ha nessun interazione con un database o dipendenza da altri servizi, sono stati creati Integration test per testare il corretto collegamento tra i servizi che utilizzano un database (relazionale e non).

\begin{lstlisting}[language=Java, caption={MongoDB integration Test}, label=list:mongo_test]
    @TestInstance(Lifecycle.PER_CLASS)
@ExtendWith(VertxExtension.class)
public class StatisticMongoTest {
	private static final int TRICKS = 10;
	private final User userTest = new User("user", UUID.randomUUID(), false);
	private static final int MARAFFA_PLAYERS = 4;
	private static final int EXPECTED_SCORE = 11;
	private static final String PASSWORD = "1234";
	private static final GameMode GAME_MODE = GameMode.CLASSIC;
	private Vertx vertx;
	private GameService gameService;
	private static final CardSuit UNDEFINED_TRUMP = CardSuit.NONE;
	private final Card<CardSuit, CardValue> cardTest = new Card<>(CardValue.THREE, CardSuit.CLUBS);
	private final Boolean isSuitFinished = true;
	private final MongoStatisticManager mongoStatisticManager = new MongoStatisticManager(
			Dotenv.configure()
					.filename("env.example").load().get("MONGO_USER", "user"),
			Dotenv.configure()
					.filename("env.example").load().get("MONGO_PASSWORD", "password"),
			Dotenv.configure()
					.filename("env.example").load().get("MONGO_HOST", "localhost"),
			Integer.parseInt(Dotenv.configure()
					.filename("env.example").load().get("MONGO_PORT", "27127")),
			Dotenv.configure().filename("env.example").load().get("MONGO_DATABASE", "maraffa-test"));

	@BeforeAll
	public void setUp() {
		this.vertx = Vertx.vertx();
		this.gameService = new GameService(this.vertx, this.mongoStatisticManager);
	}

	/**
	 * This method, called after our test, just cleanup everything by closing the
	 * vert.x instance
	 */
	@AfterAll
	public void tearDown() {
		this.vertx.close();
	}

	@Test
	public void prepareGame() {
		final String gameID = this.gameService
				.createGame(MARAFFA_PLAYERS, this.userTest, EXPECTED_SCORE, GAME_MODE.toString())
				.getString(Constants.GAME_ID);
		final var doc = this.mongoStatisticManager.getRecord(gameID + "-0");
		assertNotNull(doc);
	}
}
\end{lstlisting}
\vspace{1cm}

\subsection{Testing asincrono}

Durante la scrittura dei test all'interno del servizio in Java, alcune operazioni erano asincrone e quindi è stato necessario attendere che queste operazioni terminassero prima di poter eseguire i test e validarli.
Per fare ciò, la normale struttura di test fornita da Vertx in un primo tentativo non era sufficiente. La classica struttura dei test è la seguente:

\begin{lstlisting}[language=Java, caption={Standard Vertx test}, label=list:test_std_vertx]
@Test
public void createGameTest(final VertxTestContext context) {
    final JsonObject gameResponse = this.gameService.createGame(MARAFFA_PLAYERS, TEST_USER, EXPECTED_SCORE, GAME_MODE.toString(), PASSWORD);
    Assertions.assertEquals(UUID_SIZE, gameResponse.getString(Constants.GAME_ID).length()); // Assuming UUID is 36
    context.completeNow();
}
\end{lstlisting}

Per risolvere questo problema sono stati utilizzati:
\begin{itemize}
    \item il decoratore fornito da JUnit Jupiter \textit{@Timeout}, che permette di aspettare un tempo definito prima di fallire automaticamente il test, per ovviare al problema di asincronicità con servizi esterni al componente stesso che non "rispondono alla chiamata".
    \item l'utilizzo asincrono del VertxTestContext, che permette di completare il test solo quando tutte le operazioni asincrone sono state completate.
    \item una struttura di risposta nei servizi con cui il middleware comunica, che permette di individuare errori tramite la chiave "error" in caso di fallimento contenuta all'interno del JSON di risposta. Il test non può accedere alla response di una chiamata HTTP che normalmente avrebbe uno status code 200 in caso di successo e quindi si è ricorso a questo espediente per individuare errori nei dati inviati al servizio.
\end{itemize}

Come è possibile vedere nel test riportato di seguito, seguendo questi accorgimenti è possibile testare correttamente le operazioni asincrone.

\begin{lstlisting}[language=Java, caption={Vertx test asincrono}, label=list:test_async_vertx]
@Timeout(value = 10, unit = TimeUnit.SECONDS)
@Test
public void testgetShuffledDeckOK(final VertxTestContext context) {
    final JsonObject gameResponse = this.gameService.createGame(4, TEST_USER, 41,
            GameMode.CLASSIC.toString(), PASSWORD);
    this.businessLogicController
            .getShuffledDeck(UUID.fromString(gameResponse.getString(Constants.GAME_ID)), 4)
            .whenComplete((res, err) -> {
                context.verify(() -> {
                    assertNull(res.getString("error"));
                    context.completeNow();
                });
            });
}
\end{lstlisting}


Gli ulteriori livelli di testing sono stati accorpati durante il testing dell'applicazione tramite il suo servizio di frontend, da più utenti durante una breve fase di alpha testing.
