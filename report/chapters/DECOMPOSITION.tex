\chapter{Decomposizione da monolite a micro-servizi (Assignment 5)}

La progettazione dell'architettura microservices di MaraffaOnline segue il metodo iterativo, articolato in due passi principali: l'identificazione delle system operations e la decomposizione in servizi tramite l'approccio Domain-Driven Design (DDD).

\section{Passo 1 -- Identificazione delle System Operations}

\subsection{Domain Model di Alto Livello}

Il primo passo consiste nel costruire un domain model di alto livello, derivato dai sostantivi delle user stories principali. Questo modello definisce il vocabolario per descrivere le system operations.

Le classi chiave identificate per MaraffaOnline sono:
\begin{itemize}
    \item \textbf{Player} -- Giocatore registrato nella piattaforma
    \item \textbf{User} -- Profilo utente con credenziali e statistiche
    \item \textbf{Game} -- Partita di Maraffa (4 giocatori, 2 squadre)
    \item \textbf{Team} -- Coppia di giocatori alleati
    \item \textbf{Card} -- Carta da gioco del mazzo
    \item \textbf{Hand} -- Mano di carte di un giocatore
    \item \textbf{Trick} -- Singola presa (4 carte giocate)
    \item \textbf{Round} -- Singola mano di gioco (distribuzione carte fino a esaurimento)
    \item \textbf{ChatMessage} -- Messaggio nella chat di gioco
\end{itemize}

\noindent Si noti come il termine ``Player'' e ``User'' rappresentino lo stesso individuo ma in contesti diversi: \textbf{User} nel contesto di autenticazione e gestione profilo, \textbf{Player} nel contesto della logica di gioco. Questa polisemia è un segnale naturale dell'esistenza di bounded context distinti, dove lo stesso concetto del mondo reale assume significati e attributi diversi in ciascun contesto.

\subsection{Casi d'uso}
Si riporta di seguito lo schema dei casi d'uso che modella l'interazione dell'utente con l'applicazione.
\begin{figure}[h!]
\centering 
\includegraphics[scale=0.45]{report/img/Casi_duso.png}
\caption{Schema dei casi d'uso}
\label{use_case}
\end{figure}

\subsection{Event Storming}

Per raffinare il domain model e identificare le operazioni chiave, è stato utilizzato l'Event Storming. L'analisi ha prodotto i seguenti elementi:

 \begin{figure}[h!]
    \centering 
    \includegraphics[scale=0.45]{report/img/EventStorming.png}\\[8.5cm]
    \caption{Event Storming}
    \label{event_storming}
\end{figure}

\textbf{Domain Events}:
\begin{itemize}
    \item \texttt{UserRegistered}, \texttt{UserLoggedIn}, \texttt{UserLoggedOut}
    \item \texttt{GameCreated}, \texttt{PlayerJoined}, \texttt{GameStarted}
    \item \texttt{CardsDealt}, \texttt{CardPlayed}, \texttt{TrickWon}
    \item \texttt{MaraffaDeclared}, \texttt{RoundEnded}, \texttt{GameEnded}
    \item \texttt{MessageSent}
\end{itemize}

\textbf{Commands}:
\begin{itemize}
    \item \texttt{RegisterUser}, \texttt{Login}, \texttt{Logout}
    \item \texttt{CreateGame}, \texttt{JoinGame}, \texttt{StartGame}
    \item \texttt{DealCards}, \texttt{PlayCard}, \texttt{DeclareMaraffa}
    \item \texttt{SendMessage}
\end{itemize}

\subsection{System Operations}

Dall'analisi degli eventi e dei comandi si derivano le system operations, suddivise in \textbf{commands} (operazioni che modificano lo stato) e \textbf{queries} (operazioni di sola lettura):

\textbf{Commands:}
\begin{itemize}
    \item \texttt{createUser(username, password, email)} -- Registra un nuovo utente
    \item \texttt{login(username, password)} $\rightarrow$ token -- Autentica l'utente
    \item \texttt{createGame(playerId)} $\rightarrow$ gameId -- Crea una nuova partita
    \item \texttt{joinGame(playerId, gameId)} -- Un giocatore entra nella partita
    \item \texttt{playCard(playerId, gameId, card)} -- Gioca una carta nel turno corrente
    \item \texttt{declareMaraffa(playerId, gameId, suit)} -- Dichiara una Maraffa
    \item \texttt{sendMessage(playerId, gameId, text)} -- Invia un messaggio in chat
\end{itemize}

\textbf{Queries:}
\begin{itemize}
    \item \texttt{getGameState(gameId)} -- Stato corrente della partita
    \item \texttt{getUserProfile(userId)} -- Profilo e statistiche utente
    \item \texttt{getUserStats(userId)} -- Statistiche di gioco dell'utente
    \item \texttt{getActiveGames()} -- Lista partite disponibili
\end{itemize}

\section{Passo 2 -- Decomposizione in Servizi}

\subsection{Identificazione dei Subdomains}

Seguendo l'approccio DDD, il primo passo della decomposizione consiste nell'analizzare il dominio di business per identificare i \textbf{subdomains}, ossia le diverse aree di competenza dell'applicazione. I subdomains vengono \emph{scoperti} attraverso l'analisi del business, non progettati.

Per MaraffaOnline sono stati identificati tre subdomains:

\begin{enumerate}
    \item \textbf{Game Logic} (\textit{Core Subdomain}) -- Contiene le regole della Maraffa, la gestione delle partite, il calcolo dei punteggi e la logica dei turni. È il subdomain \textbf{core} perché rappresenta ciò che l'applicazione fa \emph{diversamente} da qualsiasi altra piattaforma: implementare correttamente le regole specifiche della Maraffa, un gioco di carte regionale con regole non banali. È naturalmente complesso e rappresenta il vantaggio competitivo dell'applicazione.

    \item \textbf{User Management} (\textit{Generic Subdomain}) -- Comprende registrazione, autenticazione, gestione profili e statistiche. È un subdomain \textbf{generic} perché l'autenticazione e la gestione utenti sono attività che tutte le applicazioni svolgono allo stesso modo, senza fornire vantaggio competitivo. Per questo tipo di subdomain, Richardson suggerisce di adottare soluzioni esistenti quando possibile.

    \item \textbf{Chat} (\textit{Supporting Subdomain}) -- Gestisce la messaggistica in tempo reale durante le partite. È un subdomain \textbf{supporting} perché supporta l'esperienza di gioco ma non fornisce vantaggio competitivo, e la sua business logic è relativamente semplice.
\end{enumerate}

\subsection{Progettazione dei Bounded Contexts}

Un bounded context definisce il confine entro cui un particular domain model è definito e applicabile, garantendo la consistenza dell'ubiquitous language al suo interno.

Per MaraffaOnline sono stati progettati due bounded contexts principali, con una corrispondenza quasi uno-a-uno con i subdomains:

\begin{enumerate}
    \item \textbf{Game Context} -- Corrisponde al core subdomain \textit{Game Logic}. Il domain model include le entità \texttt{Game}, \texttt{Player}, \texttt{Round}, \texttt{Card}, \texttt{Team}, \texttt{Trick}. In questo contesto, ``Player'' indica un partecipante attivo nella partita, con attributi come la mano di carte, il team di appartenenza e il turno corrente. L'ubiquitous language include termini specifici del gioco: mano, presa, briscola, Maraffa.

    \item \textbf{User Context} -- Corrisponde al generic subdomain \textit{User Management}. Il domain model include \texttt{User}, \texttt{Credentials}, \texttt{UserStats}. In questo contesto, ``User'' indica un profilo registrato con credenziali, email e storico partite. L'ubiquitous language è quello standard della gestione utenti: registrazione, login, profilo.
\end{enumerate}

\noindent Il subdomain \textit{Chat} non è stato implementato come bounded context autonomo: la funzionalità di messaggistica è stata integrata nel middleware, una scelta discussa nella Sezione~\ref{sec:tradeoff-middleware}.

\subsection{Context Map}
\label{sec:context-map}

La context map rappresenta visivamente le relazioni e i pattern di integrazione tra i bounded contexts del sistema:

\begin{itemize}
    \item \textbf{Game Context $\leftrightarrow$ User Context}: relazione di tipo \textbf{Customer-Supplier}. Il Game Context (downstream/customer) ha bisogno di verificare l'identità dei giocatori e aggiornare le statistiche. Lo User Context (upstream/supplier) fornisce il servizio di autenticazione e l'accesso ai profili. Il Game Context si conforma al contratto esposto dallo User Context per l'autenticazione (\textbf{Conformist}), accettando il formato del token JWT così com'è.

    \item \textbf{Middleware $\leftrightarrow$ Game Context}: il middleware agisce come API Gateway e instrada le richieste verso il Game Context. Funge da \textbf{Anticorruption Layer} parziale, traducendo le richieste HTTP/WebSocket del frontend nel formato atteso dal servizio di business logic.

    \item \textbf{Middleware $\leftrightarrow$ User Context}: il middleware instrada le richieste di autenticazione e gestione profilo verso lo User Context, operando come semplice proxy (\textbf{Conformist}), senza trasformare il modello.
\end{itemize}

\subsection{Dai Bounded Contexts ai Servizi}

Ogni bounded context è stato mappato a un microservizio indipendente, seguendo l'allineamento naturale tra DDD e architettura microservices:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Subdomain} & \textbf{Tipo} & \textbf{Bounded Context} & \textbf{Servizio} \\
\hline
Game Logic & Core & Game Context & business-logic (porta 3000) \\
\hline
User Management & Generic & User Context & user-service (porta 3001) \\
\hline
Chat & Supporting & (nel middleware) & middleware (porta 3003) \\
\hline
\end{tabular}
\caption{Mappatura subdomains $\rightarrow$ bounded contexts $\rightarrow$ servizi}
\end{table}

\subsection{Trade-off Architetturale: il Ruolo del Middleware}
\label{sec:tradeoff-middleware}

Il servizio \texttt{middleware} svolge molteplici responsabilità che, in un'architettura microservices ideale, sarebbero separate:

\begin{itemize}
    \item \textbf{API Gateway} -- Routing delle richieste HTTP verso i servizi interni
    \item \textbf{WebSocket Management} -- Gestione delle connessioni in tempo reale per gli aggiornamenti di gioco
    \item \textbf{Chat} -- Logica di messaggistica tra giocatori (subdomain \textit{supporting})
    \item \textbf{Orchestrazione parziale} -- Coordinamento tra user-service e business-logic per alcune operazioni
\end{itemize}

Questa concentrazione di responsabilità rappresenta un \textbf{trade-off consapevole}: in un progetto accademico con un team ridotto, separare ulteriormente il middleware avrebbe introdotto complessità operativa (più container, più configurazioni di rete, più punti di failure) senza un beneficio proporzionale. Tuttavia, è importante riconoscere che questa scelta \textbf{viola parzialmente} il principio di singola responsabilità a livello di servizio e potrebbe rappresentare un ostacolo alla scalabilità indipendente dei componenti in un contesto produttivo.

In una evoluzione futura, si potrebbe considerare:
\begin{itemize}
    \item Estrarre la chat in un servizio dedicato (\texttt{chat-service})
    \item Separare la gestione WebSocket in un servizio di notifiche (\texttt{notification-service})
    \item Mantenere il middleware come puro API Gateway
\end{itemize}

\section{Pattern architetturali applicati}

\subsection{API Gateway Pattern}

Il Middleware implementa il pattern API Gateway, fungendo da unico punto di ingresso per tutti i client. Questo approccio centralizza diverse funzionalità critiche:

\begin{itemize}
    \item \textbf{Routing:} smista le richieste ai microservizi corretti
    \item \textbf{Authentication:} valida i token JWT prima di inoltrare le richieste
    \item \textbf{Game Orchestration:} coordina la logica di gioco tra i servizi
    \item \textbf{WebSocket Management:} gestisce le connessioni real-time per gioco e chat
\end{itemize}

Si è seguito un approccio modulare nello sviluppo di questo componente che, in un primo step, conteneva soltanto la logica di gestione delle partite, al quale sono stati aggiunti i moduli per la comunicazione con il servizio degli utenti e della business logic. Ogni modulo segue la stessa struttura, ossia una classe denominata controller che si occupa esclusivamente della dichiarazione delle rotte HTTP e che a sua volta contiene un service. Ogni servizio contiene poi le logiche di calcolo e crea un JSON di risposta che viene passato al controller che lo invia come risposta HTTP, questo per poter separare completamente e rispettare il principio di single responsibility.

Nel modulo contenente le logiche di gioco è stato necessario aggiungere un ulteriore strato di separazione alla struttura controller-service, data la struttura multi-attore della gestione delle partite che non permetteva una separazione netta. Quindi è stato aggiunto, tra il controller e il service, un componente ibrido per poter comunque avere servizi indipendenti.

Questa separazione, oltre a essere una buona pratica, è stata scelta per poter effettuare del testing comodamente soltanto sui servizi, testando quindi solamente la parte relativa all'elaborazione di una risposta.

\subsection{Database per Service Pattern}

È stato applicato parzialmente il pattern "Database per Service" per garantire il disaccoppiamento dei dati:

\begin{itemize}
    \item \textbf{UserService:} utilizza MySQL per dati relazionali strutturati (utenti, credenziali, statistiche)
    \item \textbf{Middleware:} utilizza MongoDB per lo storico delle partite e dati flessibili
    \item \textbf{BusinessLogic:} servizio completamente stateless, non necessita di database
\end{itemize}

Ogni microservizio gestisce i propri dati in modo indipendente, evitando dipendenze dirette sui database di altri servizi.

\section{Comunicazione tra servizi}

\subsection{API Gateway}

Sono state implementate diverse forme di comunicazione tra servizi in base alle caratteristiche del messaggio che viene scambiato. Si è scelto di utilizzare la comunicazione REST nella maggior parte dei servizi, vista la sua interoperabilità.

Non è stato necessario implementare un vero e proprio broker di messaggi, ma è stato implementato un servizio denominato middleware che svolge il ruolo di API gateway delle richieste dai client verso il sistema.

Queste chiamate non sono obbligatoriamente dirette verso il servizio interessato, ma possono anche essere routine che effettuano molteplici chiamate per ottenere il risultato desiderato. 
Implementare queste chiamate direttamente nel front-end avrebbe reso il codice molto più complesso e difficile da mantenere, e la gestione di partite multiple sarebbe stata molto più complicata.

\vspace{1cm}

Non è stato implementato nessun meccanismo di discovery per scoprire l'indirizzo degli altri servizi, è stata sfruttata la tecnologia built-in di docker che permette di poter utilizzare degli alias e nascondere al proprio interno i meccanismi di registration, questo comunque implica che tutto debba essere sempre mantenuto nell'ambiente virtualizzato e quindi ogni futuro servizio containerizzato.

\subsection{WebSocket per comunicazione Real-Time}

L'interazione con il frontend avviene prevalentemente tramite il protocollo HTTP, ma per la gestione di alcuni aspetti in tempo reale sono state introdotte le WebSocket.

\subsubsection{Dashboard reattiva}
In una prima implementazione era stato utilizzato un polling per aggiornare i dati delle partite. Tramite WebSocket, è direttamente il middleware che notifica tutti i client della creazione di una nuova partita via broadcast, migliorando significativamente la reattività dell'interfaccia.

\subsubsection{Chat globale e privata}
Questo componente è stato creato per la gestione delle chat di gioco, in modo che i giocatori possano comunicare tra loro in tempo reale. Il sistema implementa due tipologie di chat:
\begin{itemize}
    \item \textbf{Chat globale:} accessibile a tutti gli utenti connessi
    \item \textbf{Chat di partita:} accessibile solo ai giocatori della partita in corso
\end{itemize}

Ogni client, istanziato sul computer degli utenti, effettua una connessione WebSocket con il middleware utilizzando come endpoint il proprio UUID, che viene assegnato automaticamente all'avvio, e lo username del giocatore, dopo aver effettuato il login. Il middleware contiene al proprio interno una mappa di tutti i client e giocatori connessi con la relativa WebSocket e una classe che espone due metodi per inviare messaggi a un singolo giocatore o effettuare un messaggio broadcast a tutti i giocatori connessi.

Il middleware si occupa di instradare i messaggi alle giuste chat, garantendo la privacy delle conversazioni di partita.

\subsubsection{Eventi di gioco}
Il modulo di game si occupa di gestire le partite, quindi è l'unico che può sapere quali giocatori devono ricevere determinati messaggi relativi a una singola partita. Per utilizzare il servizio di WebSocket, è stata implementata una semplice interfaccia all'interno dell'attore di gioco con la quale si effettuano chiamate "onEvent". Ogni volta che un particolare evento si verifica, un'invocazione a queste chiamate permette di inviare messaggi alle WebSocket dei giocatori interessati.

L'interfaccia definisce i principali eventi del ciclo di vita di una partita:
\begin{verbatim}
public interface IGameActor {
    void onCreateGame(User user);
    void onNewRound();
    void onJoinGame(User user);
    void onStartGame();
    void onPlayCard();
    void onTrickCompleted(Trick latestTrick);
    void onEndRound();
    void onEndGame();
    // ... altri eventi
}
\end{verbatim}

\section{Deployment e DevOps}

\subsection{Containerizzazione}

Ogni servizio è stato dockerizzato utilizzando \textbf{multi-stage builds} per ottenere immagini leggere e ottimizzate. Questa tecnica permette di separare la fase di build dalla fase di esecuzione, includendo nell'immagine finale solo i file strettamente necessari.

Per i servizi Node.js (UserService e BusinessLogic), il primo stage utilizza un'immagine completa per la compilazione, mentre il secondo stage copia solo i file compilati e le dipendenze di produzione.

Il middleware Java utilizza un'immagine Gradle per la build e OpenJDK per l'esecuzione, producendo un Fat JAR che include tutte le dipendenze necessarie.

Il frontend Angular viene compilato in un primo stage e poi servito tramite Nginx, che gestisce anche il reverse proxy verso i servizi backend.

\subsection{Stack Docker e reti}

Il sistema utilizza reti Docker interne per la comunicazione tra container, con IP privati assegnati automaticamente. I servizi non sono esposti direttamente all'esterno, creando un'architettura più sicura. Gli indirizzi sono configurati tramite variabili d'ambiente, facilitando la gestione di diversi ambienti di deployment.

\subsection{Struttura repository}

Il progetto utilizza \textbf{repository separate} per ogni microservizio, collegate tramite git submodules. Questa scelta garantisce:
\begin{itemize}
    \item Indipendenza nello sviluppo di ogni componente
    \item Possibilità di utilizzare workflow CI/CD specifici per ogni servizio
    \item Versionamento indipendente dei servizi
\end{itemize}

La repository principale contiene i file docker-compose per l'orchestrazione dei container e i submodules che puntano alle singole repository dei servizi.

\subsection{Continuous Integration}

Ogni repository ha workflow automatizzati tramite GitHub Actions che includono:
\begin{itemize}
    \item \textbf{Build:} compilazione del codice
    \item \textbf{Test:} esecuzione dei test automatici
    \item \textbf{Deploy:} build e push dell'immagine Docker
\end{itemize}

I workflow vengono attivati su pull request verso il branch develop e su release manuali sul branch main. Il progetto adotta \textbf{Conventional Commits} per standardizzare i messaggi di commit e facilitare la generazione automatica di changelog.

\subsection{Monitoraggio}

È stato implementato uno stack completo di monitoraggio basato su:
\begin{itemize}
    \item \textbf{cAdvisor:} raccolta metriche dei container (CPU, memoria, rete, disco)
    \item \textbf{Prometheus:} storage delle metriche time-series e sistema di alerting
    \item \textbf{Grafana:} dashboard per la visualizzazione e analisi delle performance
\end{itemize}

Questo sistema permette di monitorare in tempo reale lo stato di salute dei servizi e identificare eventuali colli di bottiglia o anomalie.

\section{Documentazione e testing}

\subsection{Swagger / OpenAPI}

Per la documentazione delle API è stato utilizzato Swagger, che genera automaticamente la documentazione interattiva:
\begin{itemize}
    \item Per i servizi Node.js: libreria che genera documentazione tramite decoratori
    \item Per i servizi Java: documentazione generata tramite annotazioni
\end{itemize}

\subsection{Postman e testing}

È stato utilizzato Postman per il testing delle API, con:
\begin{itemize}
    \item Collection di richieste esportate da Swagger
    \item Payload parametrizzati con variabili d'ambiente
    \item \textbf{Flows:} diagrammi di flusso delle richieste per simulare partite complete end-to-end
\end{itemize}

\subsection{Sistema di Logging}

Il middleware implementa un sistema di log automatici tramite LogBack che permette:
\begin{itemize}
    \item Log su file per analisi in caso di problemi
    \item Configurazione XML per personalizzazione (package, livelli, log rotate)
    \item Compressione automatica dei log oltre una certa dimensione
\end{itemize}

\section{Vantaggi e sfide}

\subsection{Vantaggi dell'architettura}

\subsubsection{Fault Tolerance}
La scelta dell'architettura a microservizi permette di \textbf{isolare parti del sistema}, evitando che gli errori si propaghino. Ogni servizio opera in modo indipendente con le proprie risorse. Tuttavia, il middleware rappresenta un Single Point of Failure che potrebbe essere mitigato implementando backup dei processi di gestione partite o ridondanza con istanze multiple.

\subsubsection{Scalabilità}
Ogni microservizio può scalare in modo indipendente in base al carico. Utilizzando orchestratori come Kubernetes è possibile bilanciare il carico tra nodi e scalare orizzontalmente aggiungendo repliche dei servizi sotto maggior stress.

\subsubsection{Indipendenza tecnologica}
L'utilizzo di due stack tecnologici differenti (Java/Vert.x per il middleware e NestJS per gli altri servizi) dimostra la flessibilità dell'architettura e permette di scegliere la tecnologia più adatta per ogni componente.

\subsection{Sfide incontrate}

Durante lo sviluppo sono emerse alcune criticità:
\begin{itemize}
    \item Complessità nella gestione della comunicazione tra servizi
    \item Necessità di coordinamento per la definizione delle interfacce API
    \item Overhead di deployment con tecnologie multiple
    \item Il middleware come single point of failure richiede attenzione particolare
\end{itemize}

\section{Conclusioni}

La decomposizione del monolite MaraffaOnline in un'architettura a microservizi ha permesso di ottenere significativi vantaggi in termini di manutenibilità, scalabilità e fault isolation. 

I pattern applicati con successo includono:
\begin{itemize}
    \item \textbf{API Gateway} per centralizzare l'accesso ai servizi
    \item \textbf{Database per Service} per il disaccoppiamento dei dati
    \item \textbf{Decompose by Subdomain} per definire confini chiari seguendo DDD
    \item \textbf{WebSocket} per la comunicazione real-time
\end{itemize}

Il sistema risultante è facilmente deployabile tramite Docker, monitorabile attraverso strumenti standard (Prometheus/Grafana) e pronto per essere scalato in base alle necessità. La separazione in microservizi indipendenti facilita inoltre la manutenzione evolutiva e l'aggiunta di nuove funzionalità senza impattare l'intero sistema.